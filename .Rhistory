}
## approximate the sum starting from 11 with an integral
approx.count <- function(t, mu, lambda, delta, n.min, n.max, t.ss){
integrand <- function(t, mu, lambda, delta, n){
if(is.infinite(n)){
return(mu*lambda*exp((lambda - delta)*t)/log(.beta(lambda, delta, t.ss-t))*( -
density.a.b.exact(lambda, delta, t.ss-t, 1, 1)))
}else{
mu*lambda*exp((lambda - delta)*t)/log(.beta(lambda, delta, t.ss-t))*(density.a.b.exact(lambda, delta, t.ss-t, 1, n) -
density.a.b.exact(lambda, delta, t.ss-t, 1, 11))
}
}
res <- integrate(integrand, lower=0, upper=t.ss, mu=mu, lambda=lambda, delta=delta, n=n.max)$value
res
}
res <- sapply(n.min, function(n.min){
if(n.min <=10){
## approximate the total number by taking the sum of the approximate count between 11 and n and the exact count between 1 and 10
total <- approx.count(t, mu, lambda, delta, 11, 100*N, t.ss) + exact.count(t, mu, lambda, delta, 10, t.ss)
if(n.min > 1){
## subtract the exact count between 1 and n.min - 1
res <- total - exact.count(t, mu, lambda, delta, n.min-1, t.ss)
}else{
res <- total
}
return(res)
}else{## approximate everything if n.min > 10
res <- approx.count(t, mu, lambda, delta, 1, Inf, t.ss) - approx.count(t, mu, lambda, delta, 1, n.min, t.ss)
return(res)
}
})
return(res)
}else{
## do full approximation
sapply(n.min, function(n.min){
res <- approx.count(t, mu, lambda, delta, 1, 100*N, t.ss) - approx.count(t, mu, lambda, delta, 1, n.min, t.ss)
return(res)
})
}
}
mutations.after.expansion(1, 0.9, 100, 1, 5, 100, "approx")
mutations.after.expansion <- function(lambda, delta, t.ss, mu, n.min, N, mode="approx"){
## for small clone sizes, compute the exact sum between 1 and 10
exact.count <- function(t, mu, lambda, delta, n, t.ss){
sum(sapply(seq(1,n), function(n){
integrand <- function(t, mu, lambda, delta, n){
mu*lambda*exp((lambda - delta)*t)*(density.a.b.exact(lambda, delta, t.ss-t, 1, n))
}
## total number of mutations acquired during exponential growth that survived:
res <- integrate(integrand, lower=0, upper=t.ss, mu=mu, lambda=lambda, delta=delta, n=n)$value
res
}))
}
## approximate the sum starting from 11 with an integral
approx.count <- function(t, mu, lambda, delta, n.min, n.max, t.ss){
integrand <- function(t, mu, lambda, delta, n){
if(is.infinite(n)){
return(mu*lambda*exp((lambda - delta)*t)/log(.beta(lambda, delta, t.ss-t))*( -
density.a.b.exact(lambda, delta, t.ss-t, 1, 1)))
}else{
mu*lambda*exp((lambda - delta)*t)/log(.beta(lambda, delta, t.ss-t))*(density.a.b.exact(lambda, delta, t.ss-t, 1, n) -
density.a.b.exact(lambda, delta, t.ss-t, 1, 11))
}
}
res <- integrate(integrand, lower=0, upper=t.ss, mu=mu, lambda=lambda, delta=delta, n=n.max)$value
res
}
if(mode=="exact"){
res <- sapply(n.min, function(n.min){
if(n.min <=10){
## approximate the total number by taking the sum of the approximate count between 11 and n and the exact count between 1 and 10
total <- approx.count(t, mu, lambda, delta, 11, 100*N, t.ss) + exact.count(t, mu, lambda, delta, 10, t.ss)
if(n.min > 1){
## subtract the exact count between 1 and n.min - 1
res <- total - exact.count(t, mu, lambda, delta, n.min-1, t.ss)
}else{
res <- total
}
return(res)
}else{## approximate everything if n.min > 10
res <- approx.count(t, mu, lambda, delta, 1, Inf, t.ss) - approx.count(t, mu, lambda, delta, 1, n.min, t.ss)
return(res)
}
})
return(res)
}else{
## do full approximation
sapply(n.min, function(n.min){
res <- approx.count(t, mu, lambda, delta, 1, 100*N, t.ss) - approx.count(t, mu, lambda, delta, 1, n.min, t.ss)
return(res)
})
}
}
mutations.after.expansion(1, 0.9, 100, 1, 5, 100, "approx")
#' Exact probability to grow from a to be within time t according to a supercritical birth-death process. Exact solution according to Bailey, 1964
#'
#' @param lambda proliferation rate
#' @param delta loss rate
#' @param t time
#' @param a clone size at t=0
#' @param b clone size at t=t
#' @return The probability that a clone of size a grows to size b within t.
#' @examples
#' density.a.b.exact(1, 0, 10, 1, 2)
#' @export
.alpha <- function(lambda, delta, t){
(delta*exp((lambda - delta)*t) - delta)/
(lambda*exp((lambda - delta)*t) - delta)
}
.beta <- function(lambda, delta, t){
(lambda*exp((lambda - delta)*t) - lambda)/
(lambda*exp((lambda-delta)*t) - delta)
}
density.a.b.exact <- function(lambda, delta, t, a, b){
if(a==1){
(1-.alpha(lambda, delta, t))*(1-.beta(lambda, delta, t))*
.beta(lambda, delta, t)^(b-1)
}else{
if(b==0){
.alpha(lambda, delta, t)^a
}else{
sum(sapply(seq(0,min(a,b)), function(j){
choose(a, j)*choose(a+b-j-1, a-1)*.alpha(lambda, delta, t)^(a-j)*.beta(lambda, delta, t)^(b-j)*(1-.alpha(lambda, delta, t)-
.beta(lambda, delta, t))^j
}))
}
}
}
#' Probability of a clone of size a to grow to size b within t according to a supercritical linear birth-death process.
#'
#' @param lambda proliferation rate
#' @param delta loss rate
#' @param t time
#' @param a clone size at t=0
#' @param b clone size at t=t
#' @param mode 'density' if density distribution is to be returned , 'cumulative' if cumulative distribution is to be returned. Defaults to 'cumulative'
#' @param approx Approximation to be used. Defaults to 'highnumbers'; i.e. we want to approximate with a gamma distribution if a and b are high.
#' @return The probability of growing from size a to size b within t. The Function switches between the exact solution and an approximate solution according to a parametrized gamma distribution.
#' @export
#'
p.a.b <- function(lambda, delta, t, a, b, mode="cumulative", approx="highnumbers"){
if(a==0){
if(mode=="density"){
if(b==0){
return(1)
}else{
return(0)
}
}else{
return(1)
}
}
if(mode=="density"){
if(a+b<=100 & approx=="highnumbers"){
density.a.b.exact(lambda, delta, t, a, b)
}else{
## Approximate with gamma-distribution, parametrized by mean and variance
mean.g <- a*exp((lambda-delta)*t)
var.g <- a*(lambda+delta)/(lambda-delta)*exp((lambda-delta)*t)*(exp((lambda-delta)*t)-1)
dgamma(b, shape=mean.g^2/var.g, scale=var.g/mean.g)
}
}else if(mode=="cumulative"){
if(a+b<=10 & approx=="highnumbers"){
## cumulative distribution
sum(sapply(seq(0, b), function(b){
## Pab according to Bailey, 1964
density.a.b.exact(lambda, delta, t, a, b)
}))
}else{
## Approximate with gamma-distribution, parametrized by mean and variance
mean.g <- a*exp((lambda-delta)*t)
var.g <- a*(lambda+delta)/(lambda-delta)*exp((lambda-delta)*t)*(exp((lambda-delta)*t)-1)
pgamma(b, shape=mean.g^2/var.g, scale=var.g/mean.g)
}
}
}
#' Expected number of neutral mutations that are present in at least n.min cells at t.ss in an exponentially growing tissue.
#'
#' @param lambda proliferation rate
#' @param delta loss rate
#' @param t.ss time
#' @param mu mutation rate per cell division
#' @param n.min minimal clone size at t.ss; can be a value or a vector
#' @param N population size
#' @param mode if "approx" the sum is approximated by integration. If "exact" the sum is exactly computed for clone sizes between 1 and 10 but beyond that also approximated.
#' @return The expected number of mutations present in at least n.min cells at t.ss in an exponentially growing tissue. The function assumes that mutations are continuously acquired at a constant rate.
#' @param export
mutations.after.expansion <- function(lambda, delta, t.ss, mu, n.min, N, mode="approx"){
## for small clone sizes, compute the exact sum between 1 and 10
exact.count <- function(t, mu, lambda, delta, n, t.ss){
sum(sapply(seq(1,n), function(n){
integrand <- function(t, mu, lambda, delta, n){
mu*lambda*exp((lambda - delta)*t)*(density.a.b.exact(lambda, delta, t.ss-t, 1, n))
}
## total number of mutations acquired during exponential growth that survived:
res <- integrate(integrand, lower=0, upper=t.ss, mu=mu, lambda=lambda, delta=delta, n=n)$value
res
}))
}
## approximate the sum starting from 11 with an integral
approx.count <- function(t, mu, lambda, delta, n.min, n.max, t.ss){
integrand <- function(t, mu, lambda, delta, n){
if(is.infinite(n)){
return(mu*lambda*exp((lambda - delta)*t)/log(.beta(lambda, delta, t.ss-t))*( -
density.a.b.exact(lambda, delta, t.ss-t, 1, 1)))
}else{
mu*lambda*exp((lambda - delta)*t)/log(.beta(lambda, delta, t.ss-t))*(density.a.b.exact(lambda, delta, t.ss-t, 1, n) -
density.a.b.exact(lambda, delta, t.ss-t, 1, 11))
}
}
res <- integrate(integrand, lower=0, upper=t.ss, mu=mu, lambda=lambda, delta=delta, n=n.max)$value
res
}
if(mode=="exact"){
res <- sapply(n.min, function(n.min){
if(n.min <=10){
## approximate the total number by taking the sum of the approximate count between 11 and n and the exact count between 1 and 10
total <- approx.count(t, mu, lambda, delta, 11, 100*N, t.ss) + exact.count(t, mu, lambda, delta, 10, t.ss)
if(n.min > 1){
## subtract the exact count between 1 and n.min - 1
res <- total - exact.count(t, mu, lambda, delta, n.min-1, t.ss)
}else{
res <- total
}
return(res)
}else{## approximate everything if n.min > 10
res <- approx.count(t, mu, lambda, delta, 1, Inf, t.ss) - approx.count(t, mu, lambda, delta, 1, n.min, t.ss)
return(res)
}
})
return(res)
}else{
## do full approximation
sapply(n.min, function(n.min){
res <- approx.count(t, mu, lambda, delta, 1, 100*N, t.ss) - approx.count(t, mu, lambda, delta, 1, n.min, t.ss)
return(res)
})
}
}
mutations.after.expansion(1, 0.9, 100, 1, 5, 100, "approx")
mutations.after.expansion <- function(lambda, delta, t.ss, mu, n.min, N, mode="approx"){
## for small clone sizes, compute the exact sum between 1 and 10
exact.count <- function(t, mu, lambda, delta, n, t.ss){
sum(sapply(seq(1,n), function(n){
integrand <- function(t, mu, lambda, delta, n){
mu*lambda*exp((lambda - delta)*t)*(density.a.b.exact(lambda, delta, t.ss-t, 1, n))
}
## total number of mutations acquired during exponential growth that survived:
res <- integrate(integrand, lower=0, upper=t.ss, mu=mu, lambda=lambda, delta=delta, n=n)$value
res
}))
}
## approximate the sum starting from 11 with an integral
approx.count <- function(t, mu, lambda, delta, n.min, n.max, t.ss){
integrand <- function(t, mu, lambda, delta, n){
if(is.infinite(n)){
return(mu*lambda*exp((lambda - delta)*t)/log(.beta(lambda, delta, t.ss-t))*( -
density.a.b.exact(lambda, delta, t.ss-t, 1, 1)))
}else{
mu*lambda*exp((lambda - delta)*t)/log(.beta(lambda, delta, t.ss-t))*(density.a.b.exact(lambda, delta, t.ss-t, 1, n) -
density.a.b.exact(lambda, delta, t.ss-t, 1, 11))
}
}
res <- integrate(integrand, lower=0, upper=t.ss, mu=mu, lambda=lambda, delta=delta, n=n.max)$value
res
}
if(mode=="exact"){
res <- sapply(n.min, function(n.min){
if(n.min <=10){
## approximate the total number by taking the sum of the approximate count between 11 and n and the exact count between 1 and 10
total <- approx.count(t, mu, lambda, delta, 11, 100*N, t.ss) + exact.count(t, mu, lambda, delta, 10, t.ss)
if(n.min > 1){
## subtract the exact count between 1 and n.min - 1
res <- total - exact.count(t, mu, lambda, delta, n.min-1, t.ss)
}else{
res <- total
}
return(res)
}else{## approximate everything if n.min > 10
res <- approx.count(t, mu, lambda, delta, 1, Inf, t.ss) - approx.count(t, mu, lambda, delta, 1, n.min, t.ss)
return(res)
}
})
return(res)
}else{
## do full approximation
sapply(n.min, function(n.min){
res <- approx.count(t, mu, lambda, delta, 1, 100*N, t.ss) - approx.count(t, mu, lambda, delta, 1, n.min, t.ss)
return(res)
})
}
sapply(n.min, function(n.min){
integrand <- function(t, mu, lambda, delta, n){
mu*lambda*exp((lambda - delta)*t)/log(.beta(lambda, delta, t.ss-t))*(density.a.b.exact(lambda, delta, t.ss-t, 1, n) -
density.a.b.exact(lambda, delta, t.ss-t, 1, 1))
}
## total number of mutations acquired during exponential growth that survived:
total <- integrate(integrand, lower=0, upper=t.ss, mu=mu, lambda=lambda, delta=delta, n=100*N)$value
res <- total - integrate(integrand, lower=0, upper=t.ss, mu=mu, lambda=lambda, delta=delta, n=n.min)$value
return(res)
})
}
mutations.after.expansion(1, 0.9, 100, 1, 5, 100, "approx")
approx.count
mutations.after.expansion <- function(lambda, delta, t.ss, mu, n.min, N, mode="approx"){
## for small clone sizes, compute the exact sum between 1 and 10
exact.count <- function(t, mu, lambda, delta, n, t.ss){
sum(sapply(seq(1,n), function(n){
integrand <- function(t, mu, lambda, delta, n){
mu*lambda*exp((lambda - delta)*t)*(density.a.b.exact(lambda, delta, t.ss-t, 1, n))
}
## total number of mutations acquired during exponential growth that survived:
res <- integrate(integrand, lower=0, upper=t.ss, mu=mu, lambda=lambda, delta=delta, n=n)$value
res
}))
}
## approximate the sum starting from 11 with an integral
approx.count <- function(t, mu, lambda, delta, n.min, n.max, t.ss){
integrand <- function(t, mu, lambda, delta, n){
if(is.infinite(n)){
return(mu*lambda*exp((lambda - delta)*t)/log(.beta(lambda, delta, t.ss-t))*( -
density.a.b.exact(lambda, delta, t.ss-t, 1, 1)))
}else{
mu*lambda*exp((lambda - delta)*t)/log(.beta(lambda, delta, t.ss-t))*(density.a.b.exact(lambda, delta, t.ss-t, 1, n) -
density.a.b.exact(lambda, delta, t.ss-t, 1, n.min))
}
}
res <- integrate(integrand, lower=0, upper=t.ss, mu=mu, lambda=lambda, delta=delta, n=n.max)$value
res
}
if(mode=="exact"){
res <- sapply(n.min, function(n.min){
if(n.min <=10){
## approximate the total number by taking the sum of the approximate count between 11 and n and the exact count between 1 and 10
total <- approx.count(t, mu, lambda, delta, 11, 100*N, t.ss) + exact.count(t, mu, lambda, delta, 10, t.ss)
if(n.min > 1){
## subtract the exact count between 1 and n.min - 1
res <- total - exact.count(t, mu, lambda, delta, n.min-1, t.ss)
}else{
res <- total
}
return(res)
}else{## approximate everything if n.min > 10
res <- approx.count(t, mu, lambda, delta, 1, Inf, t.ss) - approx.count(t, mu, lambda, delta, 1, n.min, t.ss)
return(res)
}
})
return(res)
}else{
## do full approximation
sapply(n.min, function(n.min){
res <- approx.count(t, mu, lambda, delta, 1, 100*N, t.ss) - approx.count(t, mu, lambda, delta, 1, n.min, t.ss)
return(res)
})
}
}
mutations.after.expansion(1, 0.9, 100, 1, 5, 100, "approx")
mutations.after.expansion(1, 0.9, 100, 1, 5, 100, "exact")
mutations.after.expansion(1, 0.9, 100, 1, 7, 100, "exact")
mutations.after.expansion(1, 0.9, 100, 1, 7, 100, "approx")
16864.88/17252.18
mutations.after.contraction <- function(lambda, delta, t.end, mu, n.min, N0, mode="approx"){
## Exact number of mutations present in at least n cells at time t
exact.count <- function(t, mu, lambda, delta, n, t.end){
sum(sapply(seq(1,n), function(n){
integrand <- function(t, mu, lambda, delta, n){
mu*lambda*N0*exp((lambda - delta)*t)*(density.a.b.exact(lambda, delta, t.end-t, 1, n))
}
## total number of mutations acquired during exponential growth that survived:
res <- integrate(integrand, lower=0, upper=t.end, mu=mu, lambda=lambda, delta=delta, n=n)$value
res
}))
}
approx.count <- function(t, mu, lambda, delta, n.min, n.max, t.end){
integrand <- function(t, mu, lambda, delta, n.min, n.max){
mu*lambda*N0*exp((lambda - delta)*t)/log(.beta(lambda, delta, t.end-t))*(density.a.b.exact(lambda, delta, t.end-t, 1, n.max) -
density.a.b.exact(lambda, delta, t.end-t, 1, n.min))
}
total <- integrate(integrand, lower=0, upper=t.end, mu=mu, lambda=lambda, delta=delta, n.min=n.min, n.max=n.max)$value
total
}
if(mode=="exact"){
res <- sapply(n.min, function(n.min){
if(n.min <=10){
total <- approx.count(t, mu, lambda, delta, n.min=11, n.max=100*N0, t.end) + exact.count(t, mu, lambda, delta, 10, t.end)
if(n.min > 1){
res <- total - exact.count(t, mu, lambda, delta, n.min-1, t.end)
}else{
res <- total
}
return(res)
}else{
approx.count(t, mu, lambda, delta, n.min=1, n.max=Inf) - approx.count(t, mu, lambda, delta, n.min=1, n.max=n.min)
}
})
return(res)
}
## Compute the number of mutations that are present in at least 1 cell and at most n.min cells
## The sum necessary in order to compute the cumulative distribution, is here replaced by integration.
sapply(n.min, function(n.min){
res <- approx.count(t, mu, lambda, delta, n.min=1, n.max=100*N0) - approx.count(t, mu, lambda, delta, n.min=1, n.max=n.min)
return(res)
})
}
mutations.after.contraction(1, 1.3, 100, 1, 7, 1000, "approx")
mutations.after.contraction <- function(lambda, delta, t.end, mu, n.min, N0, mode="approx"){
## Exact number of mutations present in at least n cells at time t
exact.count <- function(t, mu, lambda, delta, n, t.end){
sum(sapply(seq(1,n), function(n){
integrand <- function(t, mu, lambda, delta, n){
mu*lambda*N0*exp((lambda - delta)*t)*(density.a.b.exact(lambda, delta, t.end-t, 1, n))
}
## total number of mutations acquired during exponential growth that survived:
res <- integrate(integrand, lower=0, upper=t.end, mu=mu, lambda=lambda, delta=delta, n=n)$value
res
}))
}
approx.count <- function(t, mu, lambda, delta, n.min, n.max, t.end){
integrand <- function(t, mu, lambda, delta, n.min, n.max){
mu*lambda*N0*exp((lambda - delta)*t)/log(.beta(lambda, delta, t.end-t))*(density.a.b.exact(lambda, delta, t.end-t, 1, n.max) -
density.a.b.exact(lambda, delta, t.end-t, 1, n.min))
}
total <- integrate(integrand, lower=0, upper=t.end, mu=mu, lambda=lambda, delta=delta, n.min=n.min, n.max=n.max)$value
total
}
if(mode=="exact"){
res <- sapply(n.min, function(n.min){
if(n.min <=10){
total <- approx.count(t, mu, lambda, delta, n.min=11, n.max=100*N0, t.end) + exact.count(t, mu, lambda, delta, 10, t.end)
if(n.min > 1){
res <- total - exact.count(t, mu, lambda, delta, n.min-1, t.end)
}else{
res <- total
}
return(res)
}else{
approx.count(t, mu, lambda, delta, n.min=1, n.max=Inf, t.end) - approx.count(t, mu, lambda, delta, n.min=1, n.max=n.min, t.end)
}
})
return(res)
}
## Compute the number of mutations that are present in at least 1 cell and at most n.min cells
## The sum necessary in order to compute the cumulative distribution, is here replaced by integration.
sapply(n.min, function(n.min){
res <- approx.count(t, mu, lambda, delta, n.min=1, n.max=100*N0, t.end) - approx.count(t, mu, lambda, delta, n.min=1, n.max=n.min, t.end)
return(res)
})
}
mutations.after.contraction(1, 1.3, 100, 1, 7, 1000, "approx")
mutations.after.contraction(1, 1.3, 100, 1, 7, 1000, "exact")
mutations.after.contraction <- function(lambda, delta, t.end, mu, n.min, N0=1, N=N, mode="approx"){
## Exact number of mutations present in at least n cells at time t
exact.count <- function(t, mu, lambda, delta, n, t.end){
sum(sapply(seq(1,n), function(n){
integrand <- function(t, mu, lambda, delta, n){
mu*lambda*N0*exp((lambda - delta)*t)*(density.a.b.exact(lambda, delta, t.end-t, 1, n))
}
## total number of mutations acquired during exponential growth that survived:
res <- integrate(integrand, lower=0, upper=t.end, mu=mu, lambda=lambda, delta=delta, n=n)$value
res
}))
}
approx.count <- function(t, mu, lambda, delta, n.min, n.max, t.end){
integrand <- function(t, mu, lambda, delta, n.min, n.max){
mu*lambda*N0*exp((lambda - delta)*t)/log(.beta(lambda, delta, t.end-t))*(density.a.b.exact(lambda, delta, t.end-t, 1, n.max) -
density.a.b.exact(lambda, delta, t.end-t, 1, n.min))
}
total <- integrate(integrand, lower=0, upper=t.end, mu=mu, lambda=lambda, delta=delta, n.min=n.min, n.max=n.max)$value
total
}
if(mode=="exact"){
res <- sapply(n.min, function(n.min){
if(n.min <=10){
total <- approx.count(t, mu, lambda, delta, n.min=11, n.max=100*max(N,N0), t.end) + exact.count(t, mu, lambda, delta, 10, t.end)
if(n.min > 1){
res <- total - exact.count(t, mu, lambda, delta, n.min-1, t.end)
}else{
res <- total
}
return(res)
}else{
approx.count(t, mu, lambda, delta, n.min=1, n.max=Inf, t.end) - approx.count(t, mu, lambda, delta, n.min=1, n.max=n.min, t.end)
}
})
return(res)
}
## Compute the number of mutations that are present in at least 1 cell and at most n.min cells
## The sum necessary in order to compute the cumulative distribution, is here replaced by integration.
sapply(n.min, function(n.min){
res <- approx.count(t, mu, lambda, delta, n.min=1, n.max=100*max(N0, N), t.end) - approx.count(t, mu, lambda, delta, n.min=1, n.max=n.min, t.end)
return(res)
})
}
mutations.after.contraction(1, 1.3, 100, 1, 7, 1000, 10000, "exact")
mutations.after.contraction(1, 1.3, 100, 1, 7, 1000, 10000, "approx")
mutations.after.contraction(1, 1.3, 100, 1, 7, 1000, 100, "approx")
mutations.after.contraction(1, 0.9, 100, 1, 7, 1, 10000, "approx")
mutations.after.contraction(1, 0.9, 100, 1, 7, 1, 10000, "exact")
mutations.after.contraction(1, 1.3, 100, 1, 7, 100, 1000, "approx")
mutations.after.contraction(1, 1.3, 100, 1, 7, 50, 1000, "approx")
mutations.after.contraction(1, 1.3, 100, 1, 7, 1000, 1, "approx")
library(roxygen2)
roxygenise()
roxygenise()
roxygenise()
list.files()
roxygenise()
roxygenise()
library(Drift_and_selection)
?Extract.info.from.vcf
library(roxygen2)
roxygenise()
