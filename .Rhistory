# mu: mutation rate - prior between 0.1 and 10
# offset: number of clonal mutations - prior between 0 and 10
# N: number of stem cells - log-uniform prior between 10^2.5 and 10^8 (has to be transformed into actual values in the model function)
# delta_exp: loss rate during expansion - uniform prior between 0 and 0.7t
# lambda_ss: division rate during steady state - log-uniform prior between 10^-3 and 10^-1 (has to be transformed into actual values in the model function)
# t_s: time point of driver mutation acquisition - uniform between 0 and 1 (relative values, has to be transformed into actual values in the model function)
# s: selective advantage: uniform prior between 0 and 0.99 (relative values, have to be transformed into actual values in the model function)
prior = Distribution(mu=RV("uniform", 0.1, 9.9), offset=RV("uniform", 0, 10),  N=RV("uniform",2.5,5.5), delta_exp=RV("uniform",0,0.75), lambda_ss=RV("uniform", -3, 2), t_s=RV("uniform", 0, 1), s=RV("uniform", 0, 0.99))
from pyabc.external.r import R
abc = ABCSMC(r.myModel, prior, r.myDistance, population_size = 100)
import os
from tempfile import gettempdir
db = "sqlite:///" + "/data/A1_model_fit.db"
abc.new(db, r.mySumStatData)
history = abc.run(minimum_epsilon=1, max_nr_populations=5)
from pyabc.external.r import R
abc = ABCSMC(r.myModel, prior, r.myDistance, population_size = 100)
import os
from tempfile import gettempdir
db = "./data/A1_model_fit.db"
abc.new(db, r.mySumStatData)
history = abc.run(minimum_epsilon=1, max_nr_populations=5)
from pyabc.external.r import R
abc = ABCSMC(r.myModel, prior, r.myDistance, population_size = 100)
import os
from tempfile import gettempdir
db = "sqlite://./data/A1_model_fit.db"
abc.new(db, r.mySumStatData)
history = abc.run(minimum_epsilon=1, max_nr_populations=5)
from pyabc.external.r import R
abc = ABCSMC(r.myModel, prior, r.myDistance, population_size = 100)
import os
from tempfile import gettempdir
db = "sqlite:data/A1_model_fit.db"
abc.new(db, r.mySumStatData)
history = abc.run(minimum_epsilon=1, max_nr_populations=5)
from pyabc.external.r import R
abc = ABCSMC(r.myModel, prior, r.myDistance, population_size = 100)
import os
from tempfile import gettempdir
db = "sqlite:./data/A1_model_fit.db"
abc.new(db, r.mySumStatData)
history = abc.run(minimum_epsilon=1, max_nr_populations=5)
from pyabc.external.r import R
abc = ABCSMC(r.myModel, prior, r.myDistance, population_size = 100)
import os
from tempfile import gettempdir
db = "sqlite:" + "data/A1_model_fit.db"
abc.new(db, r.mySumStatData)
history = abc.run(minimum_epsilon=1, max_nr_populations=5)
print(os.getenv('db_user'))
print(os.getenv())
print(os.getenv(""))
print(os.getenv("koerber"))
print(os.getenv("./"))
print(os.getenv("./data/"))
from pyabc.external.r import R
abc = ABCSMC(r.myModel, prior, r.myDistance, population_size = 100)
import os
from tempfile import gettempdir
db = "sqlite:data/A1_model_fit.db"
abc.new(db, r.mySumStatData)
history = abc.run(minimum_epsilon=1, max_nr_populations=5)
from pyabc.external.r import R
abc = ABCSMC(r.myModel, prior, r.myDistance, population_size = 100)
import os
from tempfile import gettempdir
db = "sqlite:///data/A1_model_fit.db"
abc.new(db, r.mySumStatData)
history = abc.run(minimum_epsilon=1, max_nr_populations=5)
from pyabc.external.r import R
abc = ABCSMC(r.myModel, prior, r.myDistance, population_size = 100)
import os
from tempfile import gettempdir
db = "sqlite:/./data/A1_model_fit.db"
abc.new(db, r.mySumStatData)
history = abc.run(minimum_epsilon=1, max_nr_populations=5)
from pyabc.external.r import R
abc = ABCSMC(r.myModel, prior, r.myDistance, population_size = 100)
import os
from tempfile import gettempdir
db = "sqlite://./data/A1_model_fit.db"
abc.new(db, r.mySumStatData)
history = abc.run(minimum_epsilon=1, max_nr_populations=5)
from pyabc.external.r import R
abc = ABCSMC(r.myModel, prior, r.myDistance, population_size = 100)
import os
from tempfile import gettempdir
db = "sqlite:///data/A1_model_fit.db"
abc.new(db, r.mySumStatData)
history = abc.run(minimum_epsilon=1, max_nr_populations=5)
os.path.abspath("./")
os.path.relpath("./")
os.path.relpath("./data")
from pyabc.external.r import R
abc = ABCSMC(r.myModel, prior, r.myDistance, population_size = 100)
import os
from tempfile import gettempdir
db = "sqlite:data/A1_model_fit.db"
abc.new(db, r.mySumStatData)
history = abc.run(minimum_epsilon=1, max_nr_populations=5)
from pyabc.external.r import R
abc = ABCSMC(r.myModel, prior, r.myDistance, population_size = 100)
import os
from tempfile import gettempdir
db = "sqlite:A1_model_fit.db"
abc.new(db, r.mySumStatData)
history = abc.run(minimum_epsilon=1, max_nr_populations=5)
from pyabc.external.r import R
abc = ABCSMC(r.myModel, prior, r.myDistance, population_size = 100)
import os
from tempfile import gettempdir
db = "sqlite:///A1_model_fit.db"
abc.new(db, r.mySumStatData)
history = abc.run(minimum_epsilon=1, max_nr_populations=5)
from pyabc.external.r import R
abc = ABCSMC(r.myModel, prior, r.myDistance, population_size = 100)
import os
from tempfile import gettempdir
db = sqlite.connect("data/A1_model_fit.db")
abc.new(db, r.mySumStatData)
history = abc.run(minimum_epsilon=1, max_nr_populations=5)
from pyabc.external.r import R
abc = ABCSMC(r.myModel, prior, r.myDistance, population_size = 100)
import os
from tempfile import gettempdir
db = "sqlite:" + os.path("data/A1_model_fit.db")
abc.new(db, r.mySumStatData)
history = abc.run(minimum_epsilon=1, max_nr_populations=5)
from pyabc.external.r import R
abc = ABCSMC(r.myModel, prior, r.myDistance, population_size = 100)
import os
from tempfile import gettempdir
db = "sqlite:///" + os.path.relpath("data/A1_model_fit.db")
abc.new(db, r.mySumStatData)
history = abc.run(minimum_epsilon=1, max_nr_populations=5)
from pyabc.external.r import R
abc = ABCSMC(r.myModel, prior, r.myDistance, population_size = 100)
import os
from tempfile import gettempdir
db = "sqlite:" + os.path.relpath("data/A1_model_fit.db")
abc.new(db, r.mySumStatData)
history = abc.run(minimum_epsilon=1, max_nr_populations=5)
from pyabc.external.r import R
abc = ABCSMC(r.myModel, prior, r.myDistance, population_size = 100)
import os
from tempfile import gettempdir
db = "sqlite:///" + os.path.join(gettempdir(), "data/A1_model_fit.db")
abc.new(db, r.mySumStatData)
history = abc.run(minimum_epsilon=1, max_nr_populations=5)
"sqlite:///" + os.path.join(gettempdir(), "data/A1_model_fit.db")
gettempdir()
from pyabc.external.r import R
abc = ABCSMC(r.myModel, prior, r.myDistance, population_size = 100)
import os
from tempfile import gettempdir
db = "sqlite:///" + os.path.join(gettempdir(), "A1_model_fit.db")
abc.new(db, r.mySumStatData)
history = abc.run(minimum_epsilon=1, max_nr_populations=5)
from pyabc.visualization import plot_kde_2d
for t in range(history.n_populations):
df, w = abc.history.get_distribution(0, t)
ax = plot_kde_2d(
df,
w,
"meanX",
"meanY",
xmin=0,
xmax=10,
ymin=0,
ymax=10,
numx=100,
numy=100,
)
ax.scatter(
[4], [8], edgecolor="black", facecolor="white", label="Observation"
)
ax.legend()
ax.set_title(f"PDF t={t}")
from pyabc.external.r import R
np.load(path, allow_pickle=True)
abc = ABCSMC(r.myModel, prior, r.myDistance, population_size = 100)
import os
from tempfile import gettempdir
db = "sqlite:///" + os.path.join(gettempdir(), "A1_model_fit.db")
abc.new(db, r.mySumStatData)
history = abc.run(minimum_epsilon=1, max_nr_populations=5)
from pyabc.external.r import R
import numpy as np
np.load(path, allow_pickle=True)
abc = ABCSMC(r.myModel, prior, r.myDistance, population_size = 100)
import os
from tempfile import gettempdir
db = "sqlite:///" + os.path.join(gettempdir(), "A1_model_fit.db")
abc.new(db, r.mySumStatData)
history = abc.run(minimum_epsilon=1, max_nr_populations=5)
from pyabc.external.r import R
import numpy as np
abc = ABCSMC(r.myModel, prior, r.myDistance, population_size = 100)
import os
from tempfile import gettempdir
db = "sqlite:///" + os.path.join(gettempdir(), "A1_model_fit.db")
abc.new(db, r.mySumStatData, allow.pickle=True)
history = abc.run(minimum_epsilon=1, max_nr_populations=5)
from pyabc.external.r import R
abc = ABCSMC(r.myModel, prior, r.myDistance, population_size = 100)
import os
from tempfile import gettempdir
db = "sqlite:///" + os.path.join(gettempdir(), "A1_model_fit.db")
abc.new(db, r.mySumStatData)
history = abc.run(minimum_epsilon=1, max_nr_populations=5)
from pyabc.external.r import R
abc = ABCSMC(r.myModel, prior, r.myDistance, population_size = 100)
import os
from tempfile import gettempdir
db = "sqlite:///" + os.path.join(gettempdir(), "A1_model_fit.db", allow_pickle=True)
abc.new(db, r.mySumStatData)
history = abc.run(minimum_epsilon=1, max_nr_populations=5)
from pyabc.external.r import R
abc = ABCSMC(r.myModel, prior, r.myDistance, population_size = 100)
import os
from tempfile import gettempdir
db = "sqlite:///" + os.path.join(gettempdir(), "A1_model_fit.db")
abc.new(db, r.mySumStatData, allow_pickle=True)
history = abc.run(minimum_epsilon=1, max_nr_populations=5)
abc.new
abc.new()
from pyabc.external.r import R
abc = ABCSMC(r.myModel, prior, r.myDistance, population_size = 100)
import os
from tempfile import gettempdir
db = "sqlite:///" + os.path.join(gettempdir(), "A1_model_fit.db")
abc.new(db, r.mySumStatData, allow_pickle=True)
history = abc.run(minimum_epsilon=1, max_nr_populations=5)
from pyabc.external.r import R
abc = ABCSMC(r.myModel, prior, r.myDistance, population_size = 100)
import os
from tempfile import gettempdir
db = "sqlite:///" + os.path.join(gettempdir(), "A1_model_fit.db")
abc.new(db, r.mySumStatData)
history = abc.run(minimum_epsilon=1, max_nr_populations=5)
from pyabc.external.r import R
abc = ABCSMC(r.myModel, prior, r.myDistance, population_size = 100)
import os
from tempfile import gettempdir
db = "sqlite:///" + os.path.join(gettempdir(), "A1_model_fit.db")
abc.new(db, r.mySumStatData)
os.path
os.path()
os.getcwd()
os.path.join(os.getcwd(),"A1_model_fit.db")
from pyabc.external.r import R
abc = ABCSMC(r.myModel, prior, r.myDistance, population_size = 100)
import os
from tempfile import gettempdir
db = "sqlite:///" + os.path.join(os.getcwd(),"A1_model_fit.db")
abc.new(db, r.mySumStatData)
history = abc.run(minimum_epsilon=1, max_nr_populations=5)
from pyabc.external.r import R
abc = ABCSMC(r.myModel, prior, r.myDistance, population_size = 100)
import os
from tempfile import gettempdir
db = "sqlite:///" + os.path.join(os.getcwd(),"data/A1_model_fit.db")
abc.new(db, r.mySumStatData)
history = abc.run(minimum_epsilon=1, max_nr_populations=5)
from pyabc.external.r import R
abc = ABCSMC(r.myModel, prior, r.myDistance, population_size = 100)
import os
from tempfile import gettempdir
db = "sqlite:///" + os.path.join(os.getcwd(),"./data/A1_model_fit.db")
abc.new(db, r.mySumStatData)
history = abc.run(minimum_epsilon=1, max_nr_populations=5)
os.path.join(os.getcwd(),"./data/A1_model_fit.db")
os.path.join(os.getcwd(),"data/A1_model_fit.db")
from pyabc.external.r import R
abc = ABCSMC(r.myModel, prior, r.myDistance, population_size = 100)
import os
from tempfile import gettempdir
db = "sqlite:///" + os.path.join(os.getcwd(),"data/A1_model_fit.db")
abc.new(db, r.mySumStatData)
history = abc.run(minimum_epsilon=1, max_nr_populations=5)
from pyabc.external.r import R
abc = ABCSMC(r.myModel, prior, r.myDistance, population_size = 100)
import os
from tempfile import gettempdir
db = "sqlite://" + os.path.join(os.getcwd(),"data/A1_model_fit.db")
abc.new(db, r.mySumStatData)
history = abc.run(minimum_epsilon=1, max_nr_populations=5)
from pyabc.external.r import R
abc = ABCSMC(r.myModel, prior, r.myDistance, population_size = 100)
import os
from tempfile import gettempdir
db = "sqlite:" + os.path.join(os.getcwd(),"data/A1_model_fit.db")
abc.new(db, r.mySumStatData)
history = abc.run(minimum_epsilon=1, max_nr_populations=5)
from pyabc.external.r import R
abc = ABCSMC(r.myModel, prior, r.myDistance, population_size = 100)
import os
from tempfile import gettempdir
db = "sqlite://" + os.path.join(os.getcwd(),"A1_model_fit.db")
abc.new(db, r.mySumStatData)
history = abc.run(minimum_epsilon=1, max_nr_populations=5)
from pyabc.external.r import R
abc = ABCSMC(r.myModel, prior, r.myDistance, population_size = 100)
import os
from tempfile import gettempdir
db = "sqlite:/" + os.path.join(os.getcwd(),"A1_model_fit.db")
abc.new(db, r.mySumStatData)
history = abc.run(minimum_epsilon=1, max_nr_populations=5)
from pyabc.external.r import R
abc = ABCSMC(r.myModel, prior, r.myDistance, population_size = 100)
import os
from tempfile import gettempdir
db = "sqlite:///" + os.path.join(os.getcwd(),"A1_model_fit.db")
abc.new(db, r.mySumStatData)
history = abc.run(minimum_epsilon=1, max_nr_populations=5)
Session.rollback()
from pyabc.external.r import R
abc = ABCSMC(r.myModel, prior, r.myDistance, population_size = 100)
import os
from tempfile import gettempdir
db = "sqlite:///" + os.path.join(os.getcwd(),"A1_model_fit.db")
abc.new(db, r.mySumStatData)
history = abc.run(minimum_epsilon=1, max_nr_populations=5)
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(FLORENCE)
mu <- 2 # mutation per division
lambda <- 1 # division rate
delta <- 0 # death rate
N <- 1000 # final cell count
vafs.of.interest <- seq(0.01, 1, 0.01) # analyze the cumulative VAF distribution in 1% bins running between 1% and 100%
clone.sizes.of.interest <- 2*vafs.of.interest*N # in a diploid genome, the VAF is 50% of the clone size.
hist(snvs$A1$VAF, breaks=100, xlab="VAF", ylab="Number of variants")
age <- 65*365
vafs.of.interest <- seq(0.05, 1, 0.01) # define the VAFs at which the cumulative mutation count is to be evaluated
depth <- 90 # the data were generated with 90x sequencing
# filtere variants with < 3 mutant reads and with a read depth < 10 or > 300:
vafs <- lapply(snvs, function(x){
x[x$Depth>=10 & x$Depth<=300  & as.numeric(x$varCounts)>=3, ]$VAF
})
## compute the cumulative number of variants per VAF of interest
cumulated.vaf.count.mean <- lapply(vafs, function(y){
sapply(vafs.of.interest, function(x){
sum(y>=x)
})})
mySumStatData <- list(mutation.count=cumulated.vaf.count.mean, age = c(rep(age, length(vafs.of.interest))))
reticulate::repl_python()
myModel <- function(parms){
##### Parameter transformation
N <- round(10^parms$N) # prior is on log scale
delta.exp <- parms$delta_exp
lambda.ss <- 10^parms$lambda_ss # prior is on log scale
mu <- parms$mu
offset <- parms$offset
# we now restrict s and t_s to a range, where the selected clone reaches a minimal size of 0.01. Note that we will compare model and data between 0.05 VAF and 1.0 VAF - hence there is still a range of possibilities for a neutral solution (i.e., solutions where the selected clone is smaller than 10% / 5% VAF)
min.prior.size <- 0.01 # the minimal size of the selected clone in the model. Note that this
min.t.s <- 0 # the earliest time point when the driver can be acquired is at t=0.
max.t.s <- age - log(max(1, min.prior.size*N))/lambda.ss # this is the latest time point at which the clone reaches min.prior.size in the most extreme case of unrestricted growth (delta = 0) (note that we model selection on cell loss, hence the fastest growth rate of a selected clone is lambda.ss).
# now, transform the relative value of t_s into the absolute value
t.s <- min.t.s + parms$t_s*(max.t.s - min.t.s)
# in analogy, transform the relative value of s into the absolute value:
min.s <- (lambda.ss*(age-max(t.s)) - log(N))/(lambda.ss*(age-max(t.s))) # at this selective advantage, the clone will get fixed by the sampling time point. Smaller values of s hence make no sense for the observed subclones
if(min.s < 0){
min.s <- 0
}
max.s <- (lambda.ss*(age-min(t.s)) - log(max(1, min.prior.size*N)))/(lambda.ss*(age-min(t.s))) # at this selective advantage, the clone will reach at least the min.prior.size at the time point of observation. Larger values of s will not result in a visible clone.
s <- min.s + parms$s*(max.s-min.s)
# restrict s to 0, otherwise the solution cannot be evaluated
if(s < 0 & age >0){
modelResult <- rep(10^5, length(vafs.of.interest))
return( list(modelResult=modelResult))
}else if(s<0 & age==0){
## if age = 0: no time for selection yet
s <- 0.99
t.s <- 0
}
##### SFS prediction
modelResult <- list()
# define the clone sizes of interest: start from a lower VAF of 0.05/2 (where 0.05 is the smallest measurable vaf) to account for stochastic fluxes from this interval into the measurable region
min.vaf <- 0.05
clone.frequencies.for.fitting <- c(min.vaf/2, seq(min.vaf, 1, 0.01))
# take only clone frequencies that correspond to at least 1 cell
clone.frequencies.for.fitting <- clone.frequencies.for.fitting[round(clone.frequencies.for.fitting*N)>0]
# simulate the mutation counts at each clone frequency
sim <-  mutational.burden.with.selection(mu=mu, N=N, lambda.exp=1, delta.exp=delta.exp, min.clone.size = min.clone.size,
lambda.ss=lambda.ss, t.end=age, t.s=t.s[1], s=s, round(clone.frequencies.for.fitting*N))
# convert the cumulative counts into counts per interval
sim <- sim - c(sim[-1], 0)
## add offset to clonal bin
sim[clone.frequencies.for.fitting==1] <- sim[clone.frequencies.for.fitting==1] + offset
##### Add sequencing noise
# simulate sequencing assuming 90x coverage on average
sim.vafs <- simulated.data("bulk", clone.frequencies.for.fitting, sim, depth=90, sensitivity= F, false.negative.per.vaf = NULL)
# compute cumulative counts
sim.vafs <- sapply(vafs.of.interest, function(x){
sum(sim.vafs >=x)
})
###### Return the model result
modelResult[[1]] <- sim.vafs
list(modelResult=modelResult)
}
# compute distance between model and data
myDistance <- function(modelResult, mySumStatData){
res <- sum((mySumStatData$mutation.count[[1]] - modelResult$modelResult[[1]])^2)
res
}
reticulate::repl_python()
myModel(list(mu=2, offset=3, N=5, delta_exp=0, lambda_ss=-3, t_s=0.2, s=0.1))
?mutational.burden.with.selection
myModel <- function(parms){
##### Parameter transformation
N <- round(10^parms$N) # prior is on log scale
delta.exp <- parms$delta_exp
lambda.ss <- 10^parms$lambda_ss # prior is on log scale
mu <- parms$mu
offset <- parms$offset
# we now restrict s and t_s to a range, where the selected clone reaches a minimal size of 0.01. Note that we will compare model and data between 0.05 VAF and 1.0 VAF - hence there is still a range of possibilities for a neutral solution (i.e., solutions where the selected clone is smaller than 10% / 5% VAF)
min.prior.size <- 0.01 # the minimal size of the selected clone in the model. Note that this
min.t.s <- 0 # the earliest time point when the driver can be acquired is at t=0.
max.t.s <- age - log(max(1, min.prior.size*N))/lambda.ss # this is the latest time point at which the clone reaches min.prior.size in the most extreme case of unrestricted growth (delta = 0) (note that we model selection on cell loss, hence the fastest growth rate of a selected clone is lambda.ss).
# now, transform the relative value of t_s into the absolute value
t.s <- min.t.s + parms$t_s*(max.t.s - min.t.s)
# in analogy, transform the relative value of s into the absolute value:
min.s <- (lambda.ss*(age-max(t.s)) - log(N))/(lambda.ss*(age-max(t.s))) # at this selective advantage, the clone will get fixed by the sampling time point. Smaller values of s hence make no sense for the observed subclones
if(min.s < 0){
min.s <- 0
}
max.s <- (lambda.ss*(age-min(t.s)) - log(max(1, min.prior.size*N)))/(lambda.ss*(age-min(t.s))) # at this selective advantage, the clone will reach at least the min.prior.size at the time point of observation. Larger values of s will not result in a visible clone.
s <- min.s + parms$s*(max.s-min.s)
# restrict s to 0, otherwise the solution cannot be evaluated
if(s < 0 & age >0){
modelResult <- rep(10^5, length(vafs.of.interest))
return( list(modelResult=modelResult))
}else if(s<0 & age==0){
## if age = 0: no time for selection yet
s <- 0.99
t.s <- 0
}
##### SFS prediction
modelResult <- list()
# define the clone sizes of interest: start from a lower VAF of 0.05/2 (where 0.05 is the smallest measurable vaf) to account for stochastic fluxes from this interval into the measurable region
min.vaf <- 0.05
min.clone.size <- 0.05 # the lower detection limit for a selected clone with our data
clone.frequencies.for.fitting <- c(min.vaf/2, seq(min.vaf, 1, 0.01))
# take only clone frequencies that correspond to at least 1 cell
clone.frequencies.for.fitting <- clone.frequencies.for.fitting[round(clone.frequencies.for.fitting*N)>0]
# simulate the mutation counts at each clone frequency
sim <-  mutational.burden.with.selection(mu=mu, N=N, lambda.exp=1, delta.exp=delta.exp, min.clone.size = min.clone.size,
lambda.ss=lambda.ss, t.end=age, t.s=t.s[1], s=s, round(clone.frequencies.for.fitting*N))
# convert the cumulative counts into counts per interval
sim <- sim - c(sim[-1], 0)
## add offset to clonal bin
sim[clone.frequencies.for.fitting==1] <- sim[clone.frequencies.for.fitting==1] + offset
##### Add sequencing noise
# simulate sequencing assuming 90x coverage on average
sim.vafs <- simulated.data("bulk", clone.frequencies.for.fitting, sim, depth=90, sensitivity= F, false.negative.per.vaf = NULL)
# compute cumulative counts
sim.vafs <- sapply(vafs.of.interest, function(x){
sum(sim.vafs >=x)
})
###### Return the model result
modelResult[[1]] <- sim.vafs
list(modelResult=modelResult)
}
# compute distance between model and data
myDistance <- function(modelResult, mySumStatData){
res <- sum((mySumStatData$mutation.count[[1]] - modelResult$modelResult[[1]])^2)
res
}
reticulate::repl_python()
parms
prior
parms <- list(mu=2, offset=4, N=4, delta_exp=0, lambda_ss=-3, t_s=0.2, s=0.9)
myModel(parms)
test <- myModel(parms)
mySumStatData
myDistance(test, mySumStatData)
mySumStatData$mutation.count$A1
mySumStatData$age
cumulated.vaf.count.mean
age <- 65*365
vafs.of.interest <- seq(0.05, 1, 0.01) # define the VAFs at which the cumulative mutation count is to be evaluated
depth <- 90 # the data were generated with 90x sequencing
# filtere variants with < 3 mutant reads and with a read depth < 10 or > 300:
vafs <- lapply(snvs, function(x){
x[x$Depth>=10 & x$Depth<=300  & as.numeric(x$varCounts)>=3, ]$VAF
})
## compute the cumulative number of variants per VAF of interest
cumulated.vaf.count.mean <- lapply(vafs, function(y){
sapply(vafs.of.interest, function(x){
sum(y>=x)
})})
mySumStatData <- cumulated.vaf.count.mean
# compute distance between model and data
myDistance <- function(modelResult, mySumStatData){
res <- sum((mySumStatData[[1]] - modelResult$modelResult[[1]])^2)
res
}
myDistance <- function(modelResult, mySumStatData){
myDistance(test, mySumStatData)
reticulate::repl_python()
r.mySumStatData
mySumStatData
reticulate::repl_python()
py$abc.history.get_distribution(0, 2)
python$abc.history.get_distribution(0, 2)
p$abc.history.get_distribution(0, 2)
py$abc.history.get_distribution(0, 2)
reticulate::repl_python()
