res <- integrate(integrand, lower=0, upper=t.s, mu=mu, lambda=lambda, delta=delta, n=max(1,n.min-sel.size))$value
return(res)
})
mutations.in.selected.clone.prior.t.s
b <- a
## Compute the number of mutations that are present in at least 1 cell and at most n.min cells
## The sum necessary in order to compute the cumulative distribution, is here replaced by integration.
mutations.in.selected.clone.prior.t.s <- sapply(b, function(n.min){
integrand <- function(t, mu, lambda, delta, n){
p.mut.in.sel <- exp((lambda - delta)*(t.s - t))/exp((lambda - delta)*t.s)
p.mut.in.sel*mu*lambda*exp((lambda - delta)*t)*( density.a.b.exact(lambda, delta, t.end-t, 1, 0) +(density.a.b.exact(lambda, delta, t.end-t, 1, N*100) -
density.a.b.exact(lambda, delta, t.end-t, 1, n))/log(.beta(lambda, delta, t.end-t)))
}
## total number of mutations acquired during exponential growth that survived:
res <- integrate(integrand, lower=0, upper=t.s, mu=mu, lambda=lambda, delta=delta, n=max(1,n.min-sel.size))$value
return(res)
})
mutations.in.selected.clone.prior.t.s
mutations.not.in.selected.clone.prior.t.s <- sapply(b, function(n.min){
integrand <- function(t, mu, lambda, delta, n){
p.mut.in.sel <- exp((lambda - delta)*(t.s - t))/exp((lambda - delta)*t.s)
(1-p.mut.in.sel)*mu*lambda*exp((lambda - delta)*t)/log(.beta(lambda, delta, t.end-t))*(density.a.b.exact(lambda, delta, t.end-t, 1, 100*N) -
density.a.b.exact(lambda, delta, t.end-t, 1, n))
}
## total number of mutations acquired during exponential growth that survived:
res <- integrate(integrand, lower=0, upper=t.s, mu=mu, lambda=lambda, delta=delta, n=n.min)$value
return(res)
})
mutations.not.in.selected.clone.prior.t.s
library(roxygen2)
roxygenise()
library(devtools)
install_github("VerenaK90/Drift_and_selection", auth_token = "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")
library(DriftAndSelection)
p.a.b()
p.a.b
density.a.b.exact
.alpha
library(roxygen2)
roxygenise()
library(roxygen2)
roxygenise()
library(roxygen2)
roxygenize()
N <- 10^5
lambda.ss <- 2.5
lambda.exp <- 1
mu <- 3
delta.exp <- 0
t.end <- 15*7
1-0.35*10^5/(2.5*21)
1-log(0.35*10^5)/(2.5*21)
f <- function(s){exp(2.5*(1-s)*7*7) - exp(2.5*(1-s)*3*7) - 0.35*10^5}
uniroot(f, lower=0, upper=0.99)
0.8/0.91
library(DriftAndSelection)
test <- mutational.burden.with.nested.selection(mu, N, lambda.exp, delta.exp, t.end, 8*7, 12*7, 0.91, 0.88, seq(0.05, 1, 0.01)*10^5)
test <- mutational.burden.with.nested.selection(mu, N, lambda.exp, delta.exp, lambda.ss, t.end, 8*7, 12*7, 0.91, 0.88, seq(0.05, 1, 0.01)*10^5)
library(deSolve)
test <- mutational.burden.with.nested.selection(mu, N, lambda.exp, delta.exp, lambda.ss, t.end, 8*7, 12*7, 0.91, 0.88, seq(0.05, 1, 0.01)*10^5)
plot(1/seq(0.05, 1, 0.01), test)
test2 <- test - c(test[-1],0)
plot(seq(0.05, 1, 0.01), test2)
t.s <- 8*7
t.s2 <- 12*7
s1 <- 0.91
s2 <- 0.88
(exp((lambda.ss - s1*lambda.ss)*(t.end - t.s)) - exp((lambda.ss - s1*lambda.ss)*(t.end - t.s2)) +
exp((lambda.ss - s1*s2*lambda.ss)*(t.end - t.s2)))/N
8*7*3
8*7*3*2
4*7*3*3
4*7*3*2
## initialize mutation count
mutations.at.t.end <- 0
## compute the relative size of the selected clone at t.end
f.sel <- (exp((lambda.ss - s1*lambda.ss)*(t.end - t.s)) - exp((lambda.ss - s1*lambda.ss)*(t.end - t.s2)) +
exp((lambda.ss - s1*s2*lambda.ss)*(t.end - t.s2)))/N
## in case the selected clone took over, add an offset of the number of mutations in the founder cell to the solution of mutations during steady state (it's again a pure clone)
if(f.sel>1){
## when did the first clone reach 50% of N?
func <- function(t.ss){
if(t.s2 < t.ss){
(exp((lambda.ss - s1*lambda.ss)*(t.ss - t.s)) - exp((lambda.ss - s1*lambda.ss)*(t.ss - t.s2)) +
exp((lambda.ss - s1*s2*lambda.ss)*(t.ss - t.s2)))/N - 0.5
}else{
(exp((lambda.ss - s1*lambda.ss)*(t.ss - t.s)))/N - 0.5
}
}
t.ss <- uniroot(func, lower = 0, upper = t.end)$root - t.s
#t.ss <- log(N*0.5)/(lambda.ss*(1-s1))
t.end.1st.clone <- t.end - t.ss - t.s
t.s2.rel.to.1st.clone <- t.s2 - t.ss - t.s
if(t.s2.rel.to.1st.clone < 0){
t.s2.rel.to.1st.clone <- 0
}
## the mutation rate is per division, i.e., each daughter cell receives mu/2 mutations. However, the founder cell is a surviving lineage and hence divided with rate 2lambda during homeostasis, to compensate for the loss of the dying lineages
mutations.in.founder.cell <- (log(N)/(lambda.exp - delta.exp)*mu/2) + t.s*lambda.ss*mu
mutations.at.t.end <- mutational.burden.with.selection(mu, N, 1, delta.exp, lambda.ss, t.end.1st.clone, t.s2.rel.to.1st.clone, s2, b) + mutations.in.founder.cell
return(mutations.at.t.end)
}else if(f.sel <= min.clone.size){ ##just take the predicted output at t.end according to homeostatic turnover and neglect expansion of the selected clone
mutations.at.t.end <- mutational.burden(mu, N, lambda.exp, delta.exp, lambda.ss, t.end, b)
}
min.clone.size <- 0.05
## initialize mutation count
mutations.at.t.end <- 0
## compute the relative size of the selected clone at t.end
f.sel <- (exp((lambda.ss - s1*lambda.ss)*(t.end - t.s)) - exp((lambda.ss - s1*lambda.ss)*(t.end - t.s2)) +
exp((lambda.ss - s1*s2*lambda.ss)*(t.end - t.s2)))/N
## in case the selected clone took over, add an offset of the number of mutations in the founder cell to the solution of mutations during steady state (it's again a pure clone)
if(f.sel>1){
## when did the first clone reach 50% of N?
func <- function(t.ss){
if(t.s2 < t.ss){
(exp((lambda.ss - s1*lambda.ss)*(t.ss - t.s)) - exp((lambda.ss - s1*lambda.ss)*(t.ss - t.s2)) +
exp((lambda.ss - s1*s2*lambda.ss)*(t.ss - t.s2)))/N - 0.5
}else{
(exp((lambda.ss - s1*lambda.ss)*(t.ss - t.s)))/N - 0.5
}
}
t.ss <- uniroot(func, lower = 0, upper = t.end)$root - t.s
#t.ss <- log(N*0.5)/(lambda.ss*(1-s1))
t.end.1st.clone <- t.end - t.ss - t.s
t.s2.rel.to.1st.clone <- t.s2 - t.ss - t.s
if(t.s2.rel.to.1st.clone < 0){
t.s2.rel.to.1st.clone <- 0
}
## the mutation rate is per division, i.e., each daughter cell receives mu/2 mutations. However, the founder cell is a surviving lineage and hence divided with rate 2lambda during homeostasis, to compensate for the loss of the dying lineages
mutations.in.founder.cell <- (log(N)/(lambda.exp - delta.exp)*mu/2) + t.s*lambda.ss*mu
mutations.at.t.end <- mutational.burden.with.selection(mu, N, 1, delta.exp, lambda.ss, t.end.1st.clone, t.s2.rel.to.1st.clone, s2, b) + mutations.in.founder.cell
return(mutations.at.t.end)
}else if(f.sel <= min.clone.size){ ##just take the predicted output at t.end according to homeostatic turnover and neglect expansion of the selected clone
mutations.at.t.end <- mutational.burden(mu, N, lambda.exp, delta.exp, lambda.ss, t.end, b)
}
## else if 5% is reached before, take the distribution at t.s as the input for selection and neglect mutations acquired in the founder cell population after t.s. We thus have two contributions:
## selected clone + subclonal mutations acquired during expansion of the latter
## founder population:drift of mutations acquired prior to t.s
## The drift of the founder cell population is non-trivial, due to the non-exponential decay in a competing system.
## To assess it, we approximate the loss with exponential decay, requiring the same number of death events in the founder cell population
## First, death events while there's only one clone
ode.system.competition.one.mutant <- function(t, y, parms){
with(as.list(c(parms, y)), {
## number of selected cells
dm <- lambda*m*(1-m/N-s*(N-m)/N)
## number of death events in founder cell population
dDeath <- lambda*((N-m)/N + (2-s)*m/N)*(N-m)
## number of divisions in the expanding population
dDiv <- lambda*m
list(c(dm, dDeath, dDiv))
})
}
## count the number of death events until t.s2
number.of.events <- ode(func=ode.system.competition.one.mutant, times=c(0,t.s2-(t.s)), y=c(m=1, Death=0, Div=0), parms=c(lambda=lambda.ss, s=s1, N=N))
## Second, death events with two clones
ode.system.competition.two.mutants <- function(t, y, parms){
with(as.list(c(parms, y)), {
rhom1m2 <- 2-s2
rhonm1 <- 2-s1
rhonm2 <- 2-s1*s2
## number of selected m1 cells
dm1 <- lambda*m1*(1-m1/N - s1*(N-m1-m2)/N - rhom1m2*m2/N)
## number of selected m2 cells
dm2 <- lambda*m2*(1-m2/N-s1*s2*(N-m1-m2)/N - s2*m1/N)
## number of death events in founder cell population
dDeath <- lambda*((N-m1-m2)/N + rhonm1*m1/N + rhonm2*m2/N)*(N-m1-m2)
## number of divisions in the expanding population
dDiv <- lambda*(m1+m2)
list(c(dm1, dm2, dDeath, dDiv))
})
}
number.of.events <- ode(func=ode.system.competition.two.mutants, times=c(0,t.end-(t.s2)),
y=c(m1 = unname(number.of.events[2,"m"]), m2=1, number.of.events[2,"Death"], number.of.events[2,"Div"]),
parms=c(lambda=lambda.ss, s1=s1, s2=s2, N=N))
number.of.deaths.in.founder <- number.of.events[2,"Death"]
## solve for delta if modeling with exponential decay
fun <- function(lambda, delta, N, t, D){
delta*N/(lambda-delta)*(exp((lambda-delta)*t) - 1) - D
}
## re-scale to 1 to make things easier
upper <- fun(lambda=1, N=N, delta=10, t=(t.end-t.s)*lambda.ss, D=number.of.deaths.in.founder)
lower <- fun(lambda=1, N=N, delta=1+10^-10, t=(t.end-t.s)*lambda.ss, D=number.of.deaths.in.founder)
if((upper>0 & lower>0) | (upper < 0 & lower < 0)){
return(1000)
}
delta.founder <- uniroot(fun, interval=c((1+10^-10), 10), lambda=1, N=N, t=(t.end-(t.s ))*lambda.ss, D=number.of.deaths.in.founder)
delta.founder
number.of.deaths.in.founder
1.0008*10^5/(1-1.0008)*(exp((1-1.0008)*(t.end-t.s))-1)
1.0008*10^5/(1-1.0008)*(exp((1-1.0008)*(t.end-t.s))-1)-D
1.0008*10^5/(1-1.0008)*(exp((1-1.0008)*(t.end-t.s))-1)-number.of.deaths.in.founder
1.000813*10^5/(1-1.000813)*(exp((1-1.000813)*(t.end-t.s))-1)-number.of.deaths.in.founder
number.of.deaths.in.founder
number.of.deaths.in.founder/10^5
t.end-t.s
1.000813*10^5/(1-1.000813)*(exp((1-1.000813)*(t.end-t.s)*lambda.ss)-1)-number.of.deaths.in.founder
plot(seq(log(1), log(2), length.out=100), sapply(seq(log(1), log(2), length.out=100), function(delta){fun(1, delta, N, (t.end-t.s)*lambda.ss, number.of.deaths.in.founder)})
)
plot(seq(log(1), log(1.001), length.out=100), sapply(seq(log(1), log(2), length.out=100), function(delta){fun(1, delta, N, (t.end-t.s)*lambda.ss, number.of.deaths.in.founder)}))
plot(seq(log(1), log(1.001), length.out=100), sapply(seq(log(1), log(1.001), length.out=100), function(delta){fun(1, delta, N, (t.end-t.s)*lambda.ss, number.of.deaths.in.founder)}))
fun(1, 1, 10^5, (t.end-t.s)*lambda.ss, number.of.deaths.in.founder)
fun(1, 2, 10^5, (t.end-t.s)*lambda.ss, number.of.deaths.in.founder)
fun(1, 10, 10^5, (t.end-t.s)*lambda.ss, number.of.deaths.in.founder)
fun(1, 0.9, 10^5, (t.end-t.s)*lambda.ss, number.of.deaths.in.founder)
fun(1, 0.99, 10^5, (t.end-t.s)*lambda.ss, number.of.deaths.in.founder)
fun(1, 0.999, 10^5, (t.end-t.s)*lambda.ss, number.of.deaths.in.founder)
fun(1, 0.99999, 10^5, (t.end-t.s)*lambda.ss, number.of.deaths.in.founder)
fun(1, 0.99999999, 10^5, (t.end-t.s)*lambda.ss, number.of.deaths.in.founder)
fun(1, 1.00000001, 10^5, (t.end-t.s)*lambda.ss, number.of.deaths.in.founder)
fun(1, 1.0000000001, 10^5, (t.end-t.s)*lambda.ss, number.of.deaths.in.founder)
fun(1, 1.0000001, 10^5, (t.end-t.s)*lambda.ss, number.of.deaths.in.founder)
fun(1, 1.00001, 10^5, (t.end-t.s)*lambda.ss, number.of.deaths.in.founder)
fun(1, 1.001, 10^5, (t.end-t.s)*lambda.ss, number.of.deaths.in.founder)
fun(1, 1.0001, 10^5, (t.end-t.s)*lambda.ss, number.of.deaths.in.founder)
uniroot(fun, interval=c((1+10^-10), 1+10^-4), lambda=1, N=N, t=(t.end-(t.s ))*lambda.ss, D=number.of.deaths.in.founder)
uniroot(fun, interval=c((1+10^-10), 1+10^-2), lambda=1, N=N, t=(t.end-(t.s ))*lambda.ss, D=number.of.deaths.in.founder)
delta.founder <- uniroot(fun, interval=c((1+10^-10), 10), lambda=1, N=N, t=(t.end-(t.s ))*lambda.ss, D=number.of.deaths.in.founder)
## scale back
delta.founder <- delta.founder$root*lambda.ss
delta.founder
exp((lambda.ss-delta.founder)*(t.end-t.s))
if((log10(N)-1)>2){
a <- c(1, 10, 25, 50, 75, 10^seq(2, log10(N)-1, 0.05))
}else{
a <- c(1, 10, 25, 50, 75, 100)
}
a <- sort(unique(round(c(a, seq(0.105, 1, 0.05)*N))))
## compute the mutational burden at t.s
mutations.at.t.s <- mutational.burden(mu=mu, N=N, lambda.exp=lambda.exp, delta.exp=delta.exp, lambda.ss=lambda.ss, t.end=t.s, b=a)
## mutations per bin (cumulative --> discrete)
mutations.at.t.s <- mutations.at.t.s - c(mutations.at.t.s[-1],0)
bin.factor <- mutations.at.t.s/c(mutations.at.t.s[-1],0)
bin.factor[is.infinite(bin.factor)] <- 10^8
bin.factor[is.na(bin.factor)] <- 1
upper.a <- c(a[-1], 2*N)
mutations.at.t.end <- sapply(b, function(b){
## if b is bigger than the selected clone, it may contain mutations present in the founder cell population only (probability 1-a/N)
## or mutations present in both the selected clone and the founder population (probability a/N)
if(b >= f.sel*N){  ## weighted average of the probability to drift from the lower and upper boundary of the interval to a size of at least b
weighted.average <- apply(rbind(a, upper.a, bin.factor), 2, function(x){
## probability that the mutation is present in the selected clone computed at both borders of the bin
prob.sel <- x[1]/N
prob.sel.upper <- x[2]/N
p <- (x[3]* (prob.sel*(1-p.a.b(a=x[1]-1, b=b-round(f.sel*N), lambda=lambda.ss, delta=delta.founder, t=t.end-t.s)) + ## mutation in both populations (-1 because 1 cel is the selected clone)
(1-prob.sel)*(1-p.a.b(a=x[1], b=b, lambda=lambda.ss, delta=delta.founder, t=t.end-t.s))) +## mutation only in founder cell
prob.sel.upper*(1-p.a.b(a=x[2]-1, b=b-round(f.sel*N), lambda=lambda.ss, delta=delta.founder, t=t.end-t.s)) + ## mutation in both populations
(1-prob.sel.upper)*(1-p.a.b(a=x[2], b=b, lambda=lambda.ss, delta=delta.founder, t=t.end-t.s)) ## mutation only in founder cell
)/(x[3] + 1)
return(p)
})
res <- sum(mutations.at.t.s*weighted.average)
}else{ ## mutations present in at least b cells, where b <= f.sel. --> cumulative distribution from founder cell population +
## cumulative distribution from selected clone, but in this case start with f.sel at the lower end as this smaller sizes are not compatible with the selected clone.
weighted.average <- apply(rbind(a, upper.a, bin.factor), 2, function(x){
prob.sel <- x[1]/N
prob.sel.upper <- x[2]/N
p <- (x[3]* (prob.sel*(1-p.a.b(a=x[1]-1, b=0, lambda=lambda.ss, delta=delta.founder, t=t.end-t.s)) + ## mutation in both populations (-1 because 1 cel is the selected clone)
(1-prob.sel)*(1-p.a.b(a=x[1], b=b, lambda=lambda.ss, delta=delta.founder, t=t.end-t.s))) +## mutation only in founder cell
prob.sel.upper*(1-p.a.b(a=x[2]-1, b=0, lambda=lambda.ss, delta=delta.founder, t=t.end-t.s)) + ## mutation in both populations
(1-prob.sel.upper)*(1-p.a.b(a=x[2], b=b, lambda=lambda.ss, delta=delta.founder, t=t.end-t.s)) ## mutation only in founder cell
)/(x[3] + 1)
return(p)
})
res <- sum(mutations.at.t.s*weighted.average)
}
res
})
size.first.clone.at.t.s2
size.first.clone.at.t.s2 <- exp((lambda.ss - s1*lambda.ss)*(t.s2 - t.s))
size.first.clone.at.t.s2
f.sel.2 <- exp((lambda.ss - s1*s2*lambda.ss)*(t.end - t.s2))/N
f.sel.2
a <- a[a <= size.first.clone.at.t.s2]
upper.a <- c(a[-1], 2*max(a))
mutations.from.selected.clone <- mutations.noncritical.bd(lambda.ss, lambda.ss*s1, t.s2-t.s, mu, a, N=size.first.clone.at.t.s2)
mutations.from.selected.clone
## At t.s2 again, mutations could be present in the second subclone, in the first subclone or in both. Thus, consider the evolution of these mutations
## mutations per bin
mutations.from.selected.clone <- mutations.from.selected.clone - c(mutations.from.selected.clone[-1],0)
bin.factor <- mutations.from.selected.clone/c(mutations.from.selected.clone[-1],0)
bin.factor[is.infinite(bin.factor)] <- 10^8
bin.factor[is.na(bin.factor)] <- 1
mutations.at.t.end.within.selected.clone <- sapply(b, function(b){
if(b >= f.sel.2*N){ ## weighted average between lower and upper boundary of the interval
weighted.average <- apply(rbind(a, upper.a, bin.factor), 2, function(x){
## probability that the mutation is present in the selected clone computed at both borders of the bin
prob.sel <- x[1]/size.first.clone.at.t.s2
prob.sel.upper <- x[2]/size.first.clone.at.t.s2
(x[3]* (prob.sel*(1-p.a.b(a=x[1]-1, b=round(b-f.sel.2*N), lambda=lambda.ss, delta=s1*lambda.ss, t=t.end-t.s2)) + ## mutation in both populations (-1 because 1 cell is the selected clone)
(1-prob.sel)*(1-p.a.b(a=x[1], b=b, lambda=lambda.ss, delta=s1*lambda.ss, t=t.end-t.s2))) +## mutation only in founder cell
prob.sel.upper*(1-p.a.b(a=x[2]-1, b=round(b-f.sel.2*N), lambda=lambda.ss, delta=s1*lambda.ss, t=t.end-t.s2)) + ## mutation in both populations
(1-prob.sel.upper)*(1-p.a.b(a=x[2], b=b, lambda=lambda.ss, delta=s1*lambda.ss, t=t.end-t.s2)) ## mutation only in founder cell
)/(x[3] + 1)
})
res <- sum(mutations.from.selected.clone*weighted.average)
}else{ ## mutations present in at least b cells, where b <= mutations.from.selected.clone --> cumulative distribution from first selected clone +
## cumulative distribution from second selected clone, but in this case start with mutations.from.selected.clone at the lower end
## cumulative distribution from selected clone, but in this case start with f.sel.2 at the lower end as this smaller sizes are not compatible with the selected clone.
weighted.average <- apply(rbind(a, upper.a, bin.factor), 2, function(x){
prob.sel <- x[1]/size.first.clone.at.t.s2
prob.sel.upper <- x[2]/size.first.clone.at.t.s2
p <- (x[3]* (prob.sel*(1-p.a.b(a=x[1]-1, b=0, lambda=lambda.ss, delta=s1*lambda.ss, t=t.end-t.s2)) + ## mutation in both populations (-1 because 1 cel is the selected clone)
(1-prob.sel)*(1-p.a.b(a=x[1], b=b, lambda=lambda.ss, delta=s1*lambda.ss, t=t.end-t.s2))) +## mutation only in founder cell
prob.sel.upper*(1-p.a.b(a=x[2]-1, b=0, lambda=lambda.ss, delta=s1*lambda.ss, t=t.end-t.s2)) + ## mutation in both populations
(1-prob.sel.upper)*(1-p.a.b(a=x[2], b=b, lambda=lambda.ss, delta=s1*lambda.ss, t=t.end-t.s2)) ## mutation only in founder cell
)/(x[3] + 1)
return(p)
})
res <- sum(mutations.from.selected.clone*weighted.average)
}
res
})
b <- seq(0.05, 1, 0.01)*N
b
mutations.at.t.end.within.selected.clone <- sapply(b, function(b){
if(b >= f.sel.2*N){ ## weighted average between lower and upper boundary of the interval
weighted.average <- apply(rbind(a, upper.a, bin.factor), 2, function(x){
## probability that the mutation is present in the selected clone computed at both borders of the bin
prob.sel <- x[1]/size.first.clone.at.t.s2
prob.sel.upper <- x[2]/size.first.clone.at.t.s2
(x[3]* (prob.sel*(1-p.a.b(a=x[1]-1, b=round(b-f.sel.2*N), lambda=lambda.ss, delta=s1*lambda.ss, t=t.end-t.s2)) + ## mutation in both populations (-1 because 1 cell is the selected clone)
(1-prob.sel)*(1-p.a.b(a=x[1], b=b, lambda=lambda.ss, delta=s1*lambda.ss, t=t.end-t.s2))) +## mutation only in founder cell
prob.sel.upper*(1-p.a.b(a=x[2]-1, b=round(b-f.sel.2*N), lambda=lambda.ss, delta=s1*lambda.ss, t=t.end-t.s2)) + ## mutation in both populations
(1-prob.sel.upper)*(1-p.a.b(a=x[2], b=b, lambda=lambda.ss, delta=s1*lambda.ss, t=t.end-t.s2)) ## mutation only in founder cell
)/(x[3] + 1)
})
res <- sum(mutations.from.selected.clone*weighted.average)
}else{ ## mutations present in at least b cells, where b <= mutations.from.selected.clone --> cumulative distribution from first selected clone +
## cumulative distribution from second selected clone, but in this case start with mutations.from.selected.clone at the lower end
## cumulative distribution from selected clone, but in this case start with f.sel.2 at the lower end as this smaller sizes are not compatible with the selected clone.
weighted.average <- apply(rbind(a, upper.a, bin.factor), 2, function(x){
prob.sel <- x[1]/size.first.clone.at.t.s2
prob.sel.upper <- x[2]/size.first.clone.at.t.s2
p <- (x[3]* (prob.sel*(1-p.a.b(a=x[1]-1, b=0, lambda=lambda.ss, delta=s1*lambda.ss, t=t.end-t.s2)) + ## mutation in both populations (-1 because 1 cel is the selected clone)
(1-prob.sel)*(1-p.a.b(a=x[1], b=b, lambda=lambda.ss, delta=s1*lambda.ss, t=t.end-t.s2))) +## mutation only in founder cell
prob.sel.upper*(1-p.a.b(a=x[2]-1, b=0, lambda=lambda.ss, delta=s1*lambda.ss, t=t.end-t.s2)) + ## mutation in both populations
(1-prob.sel.upper)*(1-p.a.b(a=x[2], b=b, lambda=lambda.ss, delta=s1*lambda.ss, t=t.end-t.s2)) ## mutation only in founder cell
)/(x[3] + 1)
return(p)
})
res <- sum(mutations.from.selected.clone*weighted.average)
}
res
})
mutations.at.t.end.within.selected.clone
plot(1/seq(0.05, 1, 0.01), mutations.at.t.end.within.selected.clone)
plot(seq(0.05, 1, 0.01), mutations.at.t.end.within.selected.clone)
f.sel.2
abline(v=0.35)
(t.s2 - t.s)*mu*lambda.ss
(t.s2-t.s)
mu
4*4
28*3
mutations.from.selected.clone
plot(1/a, mutations.from.selected.clone)
plot(1/(a/N}, mutations.from.selected.clone)
a
plot(1/(a/N), mutations.from.selected.clone)
size.first.clone.at.t.s2
plot(1/(a/size.first.clone.at.t.s2), mutations.from.selected.clone)
plot(1/(a/size.first.clone.at.t.s2), mutations.from.selected.clone, xlim=c(0, 100, ylim=c(0, 700)))
plot(1/(a/size.first.clone.at.t.s2), mutations.from.selected.clone, xlim=c(0, 100), ylim=c(0, 700))
500/60
200/20
237/25
(1-s1)*mu*2
mu*2/(1-s1)
lambda.ss
lambda.ss*s1
mutations.noncritical.bd
mu
mutations.noncritical.bd(1, s1, 100, 3, 0.01*exp((1-s1)*100), exp((1-s1)*100))
exp((1-s1)*100)
mutations.noncritical.bd(1, s1, 100, 3, 0.01*exp((1-s1)*100), exp((1-s1)*100))
mutations.noncritical.bd(1, s1, 100, 3, c(0.01, 0.05)*exp((1-s1)*100), exp((1-s1)*100))
mutations.noncritical.bd(1, s1, 100, 3, round(0.01*exp((1-s1)*100)), exp((1-s1)*100))
exp((1-s1)*100)
size.first.clone.at.t.s2
a
t.s2-t.s
mutations.noncritical.bd(lambda.ss, lambda.ss*s1, t.s2-t.s, mu, a, N=size.first.clone.at.t.s2)
mutations.noncritical.bd(lambda.ss, lambda.ss*s1, t.s2-t.s, mu, 0.01*size.first.clone.at.t.s2, N=size.first.clone.at.t.s2)
1551/100
3/(1-s1)
mutational.burden(3, size.first.clone.at.t.s2, 1, s1, 1, 0, 0.01*size.first.clone.at.t.s2)
mutational.burden(1, size.first.clone.at.t.s2, 1, s1, 1, 0, 0.01*size.first.clone.at.t.s2)
mutational.burden(1, size.first.clone.at.t.s2, 1, 0, 1, 0, 0.01*size.first.clone.at.t.s2)
mutational.burden(3, size.first.clone.at.t.s2, 1, 0, 1, 0, 0.01*size.first.clone.at.t.s2)
plot(1/(a/size.first.clone.at.t.s2), mutations.from.selected.clone, xlim=c(0, 10), ylim=c(0, 70))
20/6
a
a <- a <- c(1, 10, 25, 50, 75, 10^seq(2, log10(size.first.clone.at.t.s2)-1, 0.05))
a <- c(1, 10, 25, 50, 75, 10^seq(2, log10(size.first.clone.at.t.s2)-1, 0.05))
a <- c(1, 10, 25, 50, 75, 10^seq(2, log10(size.first.clone.at.t.s2)-1, 0.05))
seq(2, log10(size.first.clone.at.t.s2)-1, 0.05)
log10(size.first.clone.at.t.s2)-1
a <- a <- c(1, 10, 25, 50, 75, 100)
a <- c(1, 10, 25, 50, 75, 100)
a
mutations.from.selected.clone <- mutations.noncritical.bd(lambda.ss, lambda.ss*s1, t.s2-t.s, mu, a, N=size.first.clone.at.t.s2)
mutations.from.selected.clone
a <- c(1, 10, 25, 50, 75, 100, size.first.clone.at.t.s2)
mutations.from.selected.clone <- mutations.noncritical.bd(lambda.ss, lambda.ss*s1, t.s2-t.s, mu, a, N=size.first.clone.at.t.s2)
mutations.from.selected.clone
3525/100
1/size.first.clone.at.t.s2
plot(1/(a/size.first.clone.at.t.s2), mutations.from.selected.clone)
mutations.from.selected.clone <- mutations.noncritical.bd(lambda.ss, 0*s1, t.s2-t.s, mu, a, N=size.first.clone.at.t.s2)
log(size.first.clone.at.t.s2)/lambda.ss
mutations.from.selected.clone <- mutations.noncritical.bd(lambda.ss, 0*s1, 3, mu, a, N=size.first.clone.at.t.s2)
plot(1/(a/size.first.clone.at.t.s2), mutations.from.selected.clone)
1/(a/size.first.clone.at.t.s2)
mutations.from.selected.clone
3756/545
3756/545.57
3749/543.57
mutations.at.t.end.within.selected.clone <- sapply(b, function(b){
if(b >= f.sel.2*N){ ## weighted average between lower and upper boundary of the interval
weighted.average <- apply(rbind(a, upper.a, bin.factor), 2, function(x){
## probability that the mutation is present in the selected clone computed at both borders of the bin
prob.sel <- x[1]/size.first.clone.at.t.s2
prob.sel.upper <- x[2]/size.first.clone.at.t.s2
(x[3]* (prob.sel*(1-p.a.b(a=x[1]-1, b=round(b-f.sel.2*N), lambda=lambda.ss, delta=s1*lambda.ss, t=t.end-t.s2)) + ## mutation in both populations (-1 because 1 cell is the selected clone)
(1-prob.sel)*(1-p.a.b(a=x[1], b=b, lambda=lambda.ss, delta=s1*lambda.ss, t=t.end-t.s2))) +## mutation only in founder cell
prob.sel.upper*(1-p.a.b(a=x[2]-1, b=round(b-f.sel.2*N), lambda=lambda.ss, delta=s1*lambda.ss, t=t.end-t.s2)) + ## mutation in both populations
(1-prob.sel.upper)*(1-p.a.b(a=x[2], b=b, lambda=lambda.ss, delta=s1*lambda.ss, t=t.end-t.s2)) ## mutation only in founder cell
)/(x[3] + 1)
})
res <- sum(mutations.from.selected.clone*weighted.average)
}else{ ## mutations present in at least b cells, where b <= mutations.from.selected.clone --> cumulative distribution from first selected clone +
## cumulative distribution from second selected clone, but in this case start with mutations.from.selected.clone at the lower end
## cumulative distribution from selected clone, but in this case start with f.sel.2 at the lower end as this smaller sizes are not compatible with the selected clone.
weighted.average <- apply(rbind(a, upper.a, bin.factor), 2, function(x){
prob.sel <- x[1]/size.first.clone.at.t.s2
prob.sel.upper <- x[2]/size.first.clone.at.t.s2
p <- (x[3]* (prob.sel*(1-p.a.b(a=x[1]-1, b=0, lambda=lambda.ss, delta=s1*lambda.ss, t=t.end-t.s2)) + ## mutation in both populations (-1 because 1 cel is the selected clone)
(1-prob.sel)*(1-p.a.b(a=x[1], b=b, lambda=lambda.ss, delta=s1*lambda.ss, t=t.end-t.s2))) +## mutation only in founder cell
prob.sel.upper*(1-p.a.b(a=x[2]-1, b=0, lambda=lambda.ss, delta=s1*lambda.ss, t=t.end-t.s2)) + ## mutation in both populations
(1-prob.sel.upper)*(1-p.a.b(a=x[2], b=b, lambda=lambda.ss, delta=s1*lambda.ss, t=t.end-t.s2)) ## mutation only in founder cell
)/(x[3] + 1)
return(p)
})
res <- sum(mutations.from.selected.clone*weighted.average)
}
res
})
plot(1/(b/N), mutations.at.t.end.within.selected.clone)
mutations.from.selected.clone <- mutations.noncritical.bd(lambda.ss, lambda.ss*s1, t.s2-t.s, mu, a, N=size.first.clone.at.t.s2)
## At t.s2 again, mutations could be present in the second subclone, in the first subclone or in both. Thus, consider the evolution of these mutations
## mutations per bin
mutations.from.selected.clone <- mutations.from.selected.clone - c(mutations.from.selected.clone[-1],0)
bin.factor <- mutations.from.selected.clone/c(mutations.from.selected.clone[-1],0)
bin.factor[is.infinite(bin.factor)] <- 10^8
bin.factor[is.na(bin.factor)] <- 1
mutations.at.t.end.within.selected.clone <- sapply(b, function(b){
if(b >= f.sel.2*N){ ## weighted average between lower and upper boundary of the interval
weighted.average <- apply(rbind(a, upper.a, bin.factor), 2, function(x){
## probability that the mutation is present in the selected clone computed at both borders of the bin
prob.sel <- x[1]/size.first.clone.at.t.s2
prob.sel.upper <- x[2]/size.first.clone.at.t.s2
(x[3]* (prob.sel*(1-p.a.b(a=x[1]-1, b=round(b-f.sel.2*N), lambda=lambda.ss, delta=s1*lambda.ss, t=t.end-t.s2)) + ## mutation in both populations (-1 because 1 cell is the selected clone)
(1-prob.sel)*(1-p.a.b(a=x[1], b=b, lambda=lambda.ss, delta=s1*lambda.ss, t=t.end-t.s2))) +## mutation only in founder cell
prob.sel.upper*(1-p.a.b(a=x[2]-1, b=round(b-f.sel.2*N), lambda=lambda.ss, delta=s1*lambda.ss, t=t.end-t.s2)) + ## mutation in both populations
(1-prob.sel.upper)*(1-p.a.b(a=x[2], b=b, lambda=lambda.ss, delta=s1*lambda.ss, t=t.end-t.s2)) ## mutation only in founder cell
)/(x[3] + 1)
})
res <- sum(mutations.from.selected.clone*weighted.average)
}else{ ## mutations present in at least b cells, where b <= mutations.from.selected.clone --> cumulative distribution from first selected clone +
## cumulative distribution from second selected clone, but in this case start with mutations.from.selected.clone at the lower end
## cumulative distribution from selected clone, but in this case start with f.sel.2 at the lower end as this smaller sizes are not compatible with the selected clone.
weighted.average <- apply(rbind(a, upper.a, bin.factor), 2, function(x){
prob.sel <- x[1]/size.first.clone.at.t.s2
prob.sel.upper <- x[2]/size.first.clone.at.t.s2
p <- (x[3]* (prob.sel*(1-p.a.b(a=x[1]-1, b=0, lambda=lambda.ss, delta=s1*lambda.ss, t=t.end-t.s2)) + ## mutation in both populations (-1 because 1 cel is the selected clone)
(1-prob.sel)*(1-p.a.b(a=x[1], b=b, lambda=lambda.ss, delta=s1*lambda.ss, t=t.end-t.s2))) +## mutation only in founder cell
prob.sel.upper*(1-p.a.b(a=x[2]-1, b=0, lambda=lambda.ss, delta=s1*lambda.ss, t=t.end-t.s2)) + ## mutation in both populations
(1-prob.sel.upper)*(1-p.a.b(a=x[2], b=b, lambda=lambda.ss, delta=s1*lambda.ss, t=t.end-t.s2)) ## mutation only in founder cell
)/(x[3] + 1)
return(p)
})
res <- sum(mutations.from.selected.clone*weighted.average)
}
res
})
plot(1/(b/N), mutations.at.t.end.within.selected.clone)
mutations.from.first.selected.clone <- mutations.noncritical.bd(lambda.ss, lambda.ss*s1, t.end-t.s2, mu, b, N=N)*(size.first.clone.at.t.s2-1)
mutations.from.second.selected.clone <- mutations.noncritical.bd(lambda.ss, lambda.ss*s1*s2, t.end-t.s2, mu, b, N=N)
mutations.from.founder.clone <- mutations.noncritical.bd(lambda.ss, delta.founder, t.end - t.s, mu, b, N0=N, N=(1-f.sel)*N)
mutations.from.first.selected.clone
mutations.from.second.selected.clone
mutations.from.founder.clone
test <- mutational.burden.with.nested.selection(mu, N, 1, 0, 2.5, t.end, t.s, t.s2, s1, s2, b)
plot(1/(b/N), test)
library(changer)
changer("../FLORENCE/", "FLORENCE")
roxygen2::roxygenise()
library(devtools)
install.packages("./", repos = NULL, type = "source")
install.packages("./", repos = NULL, type = "source")
library(roxygen2)
roxygenise()
install.packages("./", repos = NULL, type = "source")
roxygenise()
install.packages("./", repos = NULL, type = "source")
library(roxygen2)
roxygenise()
install.packages("./", type="source", repos = NULL)
library(roxygen)
library(roxygen2)
roxygenise()
roxygen2::roxygenise()
install.packages("./", repos = NULL, type="source")
